
      SUBROUTINE MASUB(SRELPR,IC,IEX,ND,XD,YD,ZD,TP,NXI,NYI,XI,YI,ZI,
     *                 NDIM,NOUT,IWK,WK)
C IT CARRIES OUT A SMOOTH BIVARIATE INTERPOLATION WHEN THE DATA
C POINTS PROJECTION IN THE  X-Y  PLANE IS IRREGULARLY DISTRIBUTED
C IN THE PLANE: IT ESTIMATES THE INTERPOLANT FUNCTION AT PRESCRIBED
C RECTANGULAR GRID POINTS BY MEANS OF THE 9-PARAMETERS DISCRETIZED
C VERSION OF THE NIELSON TRIANGULAR INTERPOLANT. THE REQUIRED DERIVATIVE
C VALUES ARE CALCULATED BY MINIMIZING SUITABLE TENSION'S FUNCTIONAL
C AND THE TRIANGULATION OF THE CONVEX HULL OF THE X-Y DATA IS REALIZED
C BY USING LAWSON'S LOCAL OPTIMIZATION PROCEDURE.
C IF EXTRAPOLATION IS REQUESTED (IEX PARAMETER) IT ADDS TO THE DATA
C POINTS SOME ADDITIONAL DATA, EVALUATED BY MEANS OF THE SHEPARD'S
C METHOD, SO THAT THE NEW CONVEX HULL OF THE DATA POINTS CONTAINS
C THE RECTANGULAR DOMAIN WHERE THE SURFACE HAS TO BE RECONSTRUCTED.
C
C
C THE INPUT PARAMETERS ARE
C     SRELPR = SINGLE RELATIVE PRECISION,
C     IC  = FLAG OF COMPUTATION (MUST BE 1,2,3 OR 4),
C         = 1 FOR THE FIRST CALL AND FOR NEW IEX,ND,XD-YD,
C         = 2 FOR NEW ZD,TP,
C         = 3 FOR NEW TP,
C         = 4 FOR NEW NXI,NYI,XI-YI,
C     IEX = FLAG OF COMPUTATION (MUST BE 0 OR 1),
C         = 1 (ONE) ALLOWS THE EXTRAPOLATION, 0 (ZERO) DOES NOT;
C           THIS PARAMETER MUST BE THE SAME IN THE FOLLOWING CALL,
C     ND  = NUMBER OF DATA POINTS (MUST BE 4 OR GREATER);
C           GIVEN IEX AND ND WE DEFINE N AS
C                       N = ND + IEX*(2*INT(ND/25)+4),
C     XD  = ARRAY OF DIMENSION N CONTAINING THE  X  COORDINATES OF
C           THE ND DATA POINTS,
C     YD  = ARRAY OF DIMENSION N CONTAINING THE  Y  COORDINATES OF
C           THE ND DATA POINTS,
C     ZD  = ARRAY OF DIMENSION N CONTAINING THE  Z  COORDINATES OF
C           THE ND DATA POINTS,
C     TP  = TENSION PARAMETER (MUST BE GREATER THAN OR EQUAL TO ZERO).
C     NXI = NUMBER OF RECTANGULAR GRID POINTS IN THE X COORDINATE (MUST
C           BE 1 OR GREATER),
C     NYI = NUMBER OF RECTANGULAR GRID POINTS IN THE Y COORDINATE (MUST
C           BE 1 OR GREATER),
C     XI  = ARRAY OF DIMENSION NXI CONTAINING,IN ASCENDING ORDER, THE X
C           COORDINATES OF THE RECTANGULAR GRID POINTS,  WHERE THE
C           SURFACE HAS TO BE RECONSTRUCTED,
C     YI  = ARRAY OF DIMENSION NYI CONTAINING,IN ASCENDING ORDER, THE Y
C           COORDINATES OF THE RECTANGULAR GRID POINTS,  WHERE THE
C           SURFACE HAS TO BE RECONSTRUCTED,
C     NDIM= DECLARED ROW DIMENSION OF THE ARRAY CONTAINING ZI,
C     NOUT= LOGICAL UNIT NUMBER FOR THE STANDARD OUTPUT UNIT OF THE
C           SYSTEM.
C
C THE OUTPUT PARAMETERS ARE
C     XD,YD,ZD = ARRAYS OF DIMENSION N, CONTAINING THE X, Y AND Z
C                COORDINATES OF THE ND DATA POINTS AND,IF EXTRAPOLATION
C                IS REQUESTED (IEX=1), THE X, Y AND Z COORDINATES OF
C                N-ND ADDITIONAL POINTS EVALUATED BY MEANS OF SHEPARD'S
C                METHOD. IF EXTRAPOLATION IS NOT REQUESTED (IEX=0) THEN
C                N=ND AND XD, YD, ZD ARE NOT CHANGED,
C     ZI  = DOUBLY-DIMENSIONED ARRAY OF DIMENSION NXI*NYI, WHERE THE
C           INTERPOLATED  Z  VALUES AT THE RECTANGULAR GRID POINTS ARE
C           TO BE STORED.
C           IF EXTRAPOLATION IS NOT REQUESTED (IEX=0), THE Z VALUES AT
C           THE RECTANGULAR GRID POINTS OUTSIDE THE CONVEX HULL OF THE
C           DATA POINTS, ARE SET TO 1.0E6.
C
C THE OTHER PARAMETERS ARE
C     IWK = INTEGER ARRAY OF DIMENSION  23*N-31+MAX0(8*N+25,NXI*NYI)
C           USED INTERNALLY AS WORK AREA,
C     WK  = ARRAY OF DIMENSION  19*N-20  USED INTERNALLY AS WORK AREA.
C
C THE FIRST CALL TO THIS SUBROUTINE AND THE CALL WITH A NEW ND VALUE
C AND/OR NEW CONTENTS OF THE XD AND YD ARRAYS MUST BE MADE WITH IC=1.
C THE CALL WITH IC=2 MUST BE PRECEDED BY ANOTHER CALL WITH THE SAME
C IEX,ND,NXI AND NYI VALUES AND WITH THE SAME CONTENTS OF THE XD,YD,
C XI AND YI ARRAYS.
C THE CALL WITH IC=3 MUST BE PRECEDED BY ANOTHER CALL WITH THE SAME
C IEX,ND,NXI AND NYI VALUES AND WITH THE SAME CONTENTS OF THE XD,YD,
C ZD,XI AND YI ARRAYS.
C THE CALL WITH IC=4 MUST BE PRECEDED BY ANOTHER CALL WITH THE SAME
C IEX AND ND VALUES AND WITH THE SAME CONTENTS OF THE XD,YD AND ZD
C ARRAYS.
C IWK AND WK ARRAYS MUST NOT BE DISTURBED BETWEEN THE CALL WITH IC NOT
C EQUAL TO  1  AND THE PRECEDING ONE.
C SUBROUTINE MASUB CALLS THE EXTRP,CTANG,ADJAC,PDSTE,PDMIN,ORDGR AND
C INTRP SUBROUTINES.
C
C DECLARATION STATEMENT.
      DIMENSION XD(*),YD(*),ZD(*),XI(*),YI(*),ZI(NDIM,*),IWK(*),WK(*)
      TOLL=1.0-SRELPR
C  ERROR CHECK.
8     IF(IC.LT.1.OR.IC.GT.4)GO TO 1000
      IF(IEX.LT.0.OR.IEX.GT.1)GO TO 1000
      IF(ND.LT.4)GO TO 1000
      IF(NXI.LT.1.OR.NYI.LT.1)GO TO 1000
      IF(IC.GT.1)GO TO 10
      IWK(1)=ND
      IWK(2)=IEX
      IWK(3)=NXI
      IWK(4)=NYI
      IWK(6)=ND
        IF(IEX.EQ.0)GO TO 50
        WK(1)=XI(1)
        WK(2)=XI(NXI)
        WK(3)=YI(1)
        WK(4)=YI(NYI)
        GO TO 40
10    IF(IWK(1).NE.ND) GO TO 1000
      IF(IWK(2).NE.IEX)GO TO 1000
      IF(IC.GT.3) GO TO 20
      IF(IWK(3).NE.NXI)GO TO 1000
      IF(IWK(4).NE.NYI)GO TO 1000
        IF(IC.EQ.2.AND.IEX.EQ.1)GO TO 40
        GO TO 50
20    IWK(3)=NXI
      IWK(4)=NYI
        IF(IEX.EQ.0)GO TO 50
        IF(XI(1).LT.WK(1).OR.XI(NXI).GT.WK(2))GO TO 1000
        IF(YI(1).LT.WK(3).OR.YI(NYI).GT.WK(4))GO TO 1000
        GO TO 50
C ADDS SOME EXTERNAL POINTS FOR THE EXTRAPOLATION.
40    CALL EXTRP(ND,XD,YD,ZD,IC,IWK,WK(1),WK(2),WK(3),WK(4))
50    NDP=IWK(6)
C ALLOCATION STORAGE AREAS IN THE IWK AND WK ARRAYS.
      JIPT=8
      JIPL=6*NDP-7
      JIWP=12*NDP-7
      JIND=13*NDP-7
      JNGP=19*NDP-22
      JIGP=23*NDP-32
      IPD=5
      IAL=2*NDP+5
      IBE=5*NDP-1
      IGA=8*NDP-7
      IEI=11*NDP-13
      IALS=14*NDP-19
      IBES=IALS+NDP
      IGAS=IBES+NDP
      IZX=IGAS+NDP
      IZY=IZX+NDP
      IF(IC.GT.1)GO TO 60
C TRIANGULATES THE X-Y PLANE.
      CALL CTANG(NDP,XD,YD,NOUT,NT,IWK(JIPT),IWK(JIPL),IWK(JIND),
     *           IWK(JIWP),WK(IPD))
      IWK(5)=NT
C CONSTRUCTS THE ADJACENCIES MONODIMENSIONAL ARRAY.
      CALL ADJAC(NT,IWK(JIPT),NDP,IWK(JIPL),IWK(JIWP-1))
60    NT=IWK(5)
      IF(IC.GT.3)GO TO 70
      IF(IC.EQ.3)GO TO 65
C ESTIMATES PARTIAL DERIVATIVES AT ALL DATA POINTS.
      CALL PDSTE(NDP,XD,YD,ZD,NT,IWK(JIPT),WK(IPD),IWK(JIND))
65    CALL PDMIN(SRELPR,NDP,XD,YD,ZD,NOUT,IWK(JIPL),IWK(JIWP-1),
     *     IWK(JIND),TP,WK(IPD),WK(IAL),WK(IBE),WK(IGA),WK(IEI),
     *     WK(IALS),WK(IBES),WK(IGAS),WK(IZX),WK(IZY))
      IF(IC.GT.1)GO TO 80
C SORTS RECTANGULAR GRID POINTS ACCORDING TO THEIR BELONGING TO THE
C TRIANGLES.
70    CALL ORDGR(XD,YD,NT,IWK(JIPT),NXI,NYI,XI,YI,IWK(JNGP),
     *           IWK(JIGP))
80    DO 85 I=1,NXI
      DO 85 J=1,NYI
85    ZI(I,J)=1.E6
      ITPV=0
      IMAX=0
      I1MIN=NXI*NYI+1
      DO 120 KNGP=1,NT
        ITI=KNGP
        JWNGP=JNGP-1+KNGP
        NGP0=IWK(JWNGP)
        IF(NGP0.EQ.0)GO TO 100
        IMIN=IMAX+1
        IMAX=IMAX+NGP0
        DO 90 KIGP=IMIN,IMAX
          JWIGP=JIGP+KIGP-1
          IZI=IWK(JWIGP)
          IYI=(IZI-1)/NXI+1
          IXI=IZI-NXI*(IYI-1)
          CALL INTRP(SRELPR,TOLL,XD,YD,ZD,IWK(JIPT),WK(IPD),ITI,ITPV,
     *               XI(IXI),YI(IYI),ZI(IXI,IYI))
90      CONTINUE
100     JWNGP=JNGP+2*NT-KNGP
        NGP1=IWK(JWNGP)
        IF(NGP1.EQ.0)GO TO 120
        I1MAX=I1MIN-1
        I1MIN=I1MIN-NGP1
        DO 110 KIGP=I1MIN,I1MAX
          JWIGP=JIGP+KIGP-1
          IZI=IWK(JWIGP)
          IYI=(IZI-1)/NXI+1
          IXI=IZI-NXI*(IYI-1)
          CALL INTRP(SRELPR,TOLL,XD,YD,ZD,IWK(JIPT),WK(IPD),ITI,ITPV,
     *               XI(IXI),YI(IYI),ZI(IXI,IYI))
110     CONTINUE
120   CONTINUE
      RETURN
C ERROR EXIT.
1000  WRITE(NOUT,130)IEX,IC,ND
130   FORMAT(1X,34HIMPROPER INPUT PARAMETER VALUE(S)./
     *       4HIEX=,I4,4H IC=,I4,4H ND=,I4)
      RETURN
      END
      SUBROUTINE EXTRP(ND,X,Y,Z,KC,IWK,A,B,C,D)
C IT ADDS SOME EXTERNAL POINTS TO THE DATA POINT SET AND ESTIMATES
C THE Z COORDINATE AT THESE POINTS FOLLOWING THE SHEPARD METHOD.
C
C THE INPUT PARAMETERS ARE
C     ND  = NUMBER OF DATA POINTS,
C     X,Y,Z = ARRAYS OF DIMENSION  ND  CONTAINING THE  X,Y  AND  Z
C             COORDINATES OF THE DATA POINTS,
C     KC  = FLAG OF COMPUTATION,
C     A,B,C,D = EXTREME OF THE RECTANGULAR GRID POINTS.
C
C THE OUTPUT PARAMETERS ARE
C     X,Y,Z = ARRAYS OF DIMENSION  NDP  CONTAINING THE  X,Y  AND  Z
C             COORDINATES OF THE NEW SET OF DATA POINTS WHERE
C                 NDP = ND+2*INT(ND/25)+4,
C     A,B,C,D = EXTREME OF THE RECTANGULAR REGION CONTAINING THE DATA
C               POINT SET AND THE RECTANGULAR GRID POINTS.
C
C THE OTHER PARAMETER IS
C     IWK = INTEGER ARRAY OF DIMENSION 4*ND+7 USED AS WORK AREA.
C
C DECLARATION STATEMENT.
      DIMENSION X(*),Y(*),Z(*),IWK(*),DIST(5),IPC0(5)
C STATEMENT FUNCTIONS.
      DINF(U1,V1,U2,V2)=AMAX1(ABS(U1-U2),ABS(V1-V2))
      DSQF(U1,V1,U2,V2)=((U2-U1)**2+(V2-V1)**2)**2
      NDP=IWK(6)
      NCP=IWK(7)
      IF(KC.EQ.2)GO TO 200
C  ESTIMATES THE SMALLEST RECTANGLE CONTAINING THE DATA POINT SET
C  AND THE RECTANGULAR GRID POINTS.
      JA=0
      IA=7
      JB=0
      IB=IA+ND
      JC=0
      IC=IB+ND
      JD=0
      ID=IC+ND
      DO 50 I=1,ND
        IF(X(I)-A)16,18,20
16        JA=0
18        JA=JA+1
          IWK(IA+JA)=I
          A=X(I)
          GO TO 30
20      IF(B-X(I))26,28,30
26        JB=0
28        JB=JB+1
          IWK(IB+JB)=I
          B=X(I)
30      IF(Y(I)-C)36,38,40
36        JC=0
38        JC=JC+1
          IWK(IC+JC)=I
          C=Y(I)
          GO TO 50
40      IF(D-Y(I))46,48,50
46        JD=0
48        JD=JD+1
          IWK(ID+JD)=I
          D=Y(I)
50    CONTINUE
C  ESTIMATES THE NUMBER OF POINTS AND WHERE THEY HAVE TO BE ADJOINTED.
      N=ND/25
      BMA=B-A
      DMC=D-C
      HX=BMA
      HY=DMC
      NX=1
      NY=1
      IF(N.EQ.0)GO TO 75
        DO 70 I=1,N
          IF(HX.GT.HY)GO TO 60
            NY=NY+1
            HY=DMC/FLOAT(NY)
          GO TO 70
60          NX=NX+1
            HX=BMA/FLOAT(NX)
70      CONTINUE
      HX=BMA/FLOAT(NX)
      HY=DMC/FLOAT(NY)
C  ADDS THE NEW EXTERNAL POINTS AND CHECKS THAT THEY ARE NOT
C  COINCIDENT WITH THE OLD ONES.
75    NDP=ND+1
      YP=C
      DO 100 I=1,NY
        IF(JA.EQ.0)GO TO 80
          DO 77 J=1,JA
            IF(YP.EQ.Y(IWK(IA+J)))GO TO 90
77        CONTINUE
80      X(NDP)=A
        Y(NDP)=YP
        NDP=NDP+1
90      YP=YP+HY
100   CONTINUE
      XP=A
      DO 130 I=1,NX
        IF(JD.EQ.0)GO TO 110
          DO 105 J=1,JD
            IF(XP.EQ.X(IWK(ID+J)))GO TO 120
105       CONTINUE
110     X(NDP)=XP
        Y(NDP)=D
        NDP=NDP+1
120     XP=XP+HX
130   CONTINUE
      YP=D
      DO 160 I=1,NY
        IF(JB.EQ.0)GO TO 140
          DO 135 J=1,JB
            IF(YP.EQ.Y(IWK(IB+J)))GO TO 150
135       CONTINUE
140     X(NDP)=B
        Y(NDP)=YP
        NDP=NDP+1
150     YP=YP-HY
160   CONTINUE
      XP=B
      DO 190 I=1,NX
        IF(JC.EQ.0)GO TO 170
          DO 165 J=1,JC
            IF(XP.EQ.X(IWK(IC+J)))GO TO 180
165       CONTINUE
170     X(NDP)=XP
        Y(NDP)=C
        NDP=NDP+1
180     XP=XP-HX
190   CONTINUE
      NDP=NDP-1
      IWK(6)=NDP
      NCP=5
      IF(ND.LE.5)NCP=3
      IWK(7)=NCP
C  ESTIMATES THE FUNCTION VALUE AT THE NEW EXTERNAL POINTS.
C
200   N1=ND+1
        DO 270 IP1=N1,NDP
          X0=X(IP1)
          Y0=Y(IP1)
          DMX=0.
            DO 220 IP2=1,ND
              DM=DINF(X0,Y0,X(IP2),Y(IP2))
              DIST(IP2)=DM
              IPC0(IP2)=IP2
                IF(DM.LE.DMX)GO TO 210
                  DMX=DM
                  JMX=IP2
210             IF(IP2.GE.NCP)GO TO 230
220         CONTINUE
230       IP2P1=IP2+1
            DO 250 IP2=IP2P1,ND
              DM=DINF(X0,Y0,X(IP2),Y(IP2))
                IF(DM.GE.DMX)GO TO 250
                  DIST(JMX)=DM
                  IPC0(JMX)=IP2
                  DMX=0.
                    DO 240 J1=1,NCP
                      IF(DIST(J1).LE.DMX)GO TO 240
                        DMX=DIST(J1)
                        JMX=J1
240                 CONTINUE
250         CONTINUE
        ANUM=0.
        ADEN=0.
          DO 260 J2=1,NCP
            IP2=IPC0(J2)
            R4=DSQF(X0,Y0,X(IP2),Y(IP2))
              IF(R4.EQ.0)GO TO 260
                ANUM=ANUM+Z(IP2)/R4
                ADEN=ADEN+1/R4
260       CONTINUE
        Z(IP1)=ANUM/ADEN
270   CONTINUE
      RETURN
      END
      SUBROUTINE PDMIN(SRELPR,N,X,Y,Z,NOUT,IADVE,NADVE,INDEX,TP,PD,
     *                 ALFA,BETA,GAMMA,EIJQ,ALFAS,BETAS,GAMMAS,ZX,ZY)
C IT ESTIMATES THE FIRST ORDER PARTIAL DERIVATIVE VALUES AT
C THE DATA POINTS BY MEANS OF A GLOBAL METHOD BASED ON A MINIMUM
C NORM UNDER TENSION NETWORK .
C
C THE INPUT PARAMETERS ARE
C     SRELPR = SINGLE RELATIVE PRECISION
C     N   = NUMBER OF DATA POINTS,
C     X,Y,Z = ARRAY OF DIMENSION N CONTAINING THE X,Y AND Z
C             COORDINATES OF THE DATA POINTS,
C     NOUT = LOGICAL UNIT NUMBER FOR THE STANDARD OUTPUT UNIT OF THE
C            SYSTEM,
C     IADVE = INTEGER ARRAY OF DIMENSION 6*N-12 CONTAINING THE INDICES
C             OF THE VERTEXES ADJACENT TO EACH VERTEX IN THE
C             TRIANGULATION,
C     NADVE = INTEGER ARRAY OF DIMENSION N+1 CONTAINING THE NUMBER OF
C             THE VERTEXES ADJACENT TO EACH VERTEX IN THE TRIANGULATION
C     TP  = TENSION PARAMETER,
C     PD  = ARRAY OF DIMENSION 2*N CONTAINING AN INITIAL EVALUATION
C           OF THE PARTIAL DERIVATIVE VALUES AT THE DATA POINTS.
C
C THE OUTPUT PARAMETER IS
C     PD  = ARRAY OF DIMENSION 2*N CONTAINING THE PARTIAL DERIVATIVE
C           VALUES AT THE DATA POINTS.
C
C THE OTHER PARAMETERS ARE
C     INDEX = INTEGER ARRAY OF DIMENSION 6*N-15 USED INTERNALLY AS
C             WORK AREA,
C     ALFA,BETA,GAMMA,EIJQ = ARRAYS OF DIMENSION 3*N-6 USED INTERNALLY
C                            AS WORK AREAS,
C     ALFAS,BETAS,GAMMAS,ZX,ZY = ARRAYS OF DIMENSION N USED INTERNALLY
C                                AS WORK AREAS.
C
C  THE  RELER  CONSTANT IN THE DATA  INITIALIZATION STATEMENT  IS A
C  RELATIVE ERROR TOLERANCE TO STOP THE ITERATIVE METHOD.
C  THEREFORE IT IS MACHINE DEPENDENT;
C  THE ABSOLUTE ERROR TOLERANCE  TAU  IS THEN OBTAINED BY
C         TAU=RELER*AMAX1(ABS(PD(I)),I=1,2*N)+2*N*SRELPR.
C
C DECLARATION STATEMENTS.
      DIMENSION X(*),Y(*),Z(*),IADVE(*),NADVE(*),PD(*)
      DIMENSION INDEX(*),ALFA(*),BETA(*),GAMMA(*),EIJQ(*),
     *          ALFAS(*),BETAS(*),GAMMAS(*),ZX(*),ZY(*)
      DATA RELER/1.E-5/
C  CALCULATES THE PART OF MATRIX COEFFICIENTS INDEPENDENT
C  FROM THE TENSION PARAMETER TP.
      K=0
      PDM=0.0
        DO 60 I=1,N
          J=I+I
          PDM=AMAX1(PDM,ABS(PD(J)),ABS(PD(J-1)))
          ZX(I)=0.
          ZY(I)=0.
          ALFAS(I)=0.
          BETAS(I)=0.
          GAMMAS(I)=0.
          JIN=NADVE(I)+1
          JFIN=NADVE(I+1)
            DO 50 J=JIN,JFIN
              IND=IADVE(J)
              DX=X(I)-X(IND)
              DY=Y(I)-Y(IND)
              DZ=Z(I)-Z(IND)
              DXQ=DX*DX
              DYQ=DY*DY
              ALUNQ=DXQ+DYQ
              AL3=ALUNQ*SQRT(ALUNQ)
              ZX(I)=ZX(I)+DZ*DX/AL3
              ZY(I)=ZY(I)+DZ*DY/AL3
                IF(IND.GT.I)GO TO 30
                  LIN=NADVE(IND)+1
                  LFIN=NADVE(IND+1)
                    DO 10 L=LIN,LFIN
                      IF(I.EQ.IADVE(L))GO TO 20
   10               CONTINUE
   20             INDEX(J)=INDEX(L)
                  GO TO 40
   30         K=K+1
              INDEX(J)=K
              AL3P2=AL3+AL3
              EIJQ(K)=ALUNQ
              ALFA(K)=DXQ/AL3P2
              BETA(K)=DX*DY/AL3P2
              GAMMA(K)=DYQ/AL3P2
   40       ALFAS(I)=ALFAS(I)+ALFA(INDEX(J))
            BETAS(I)=BETAS(I)+BETA(INDEX(J))
            GAMMAS(I)=GAMMAS(I)+GAMMA(INDEX(J))
   50       CONTINUE
          ZX(I)=3.*ZX(I)/2.
          ZY(I)=3.*ZY(I)/2.
          ALFAS(I)=2.*ALFAS(I)
          BETAS(I)=2.*BETAS(I)
          GAMMAS(I)=2.*GAMMAS(I)
   60   CONTINUE
      IF(TP.EQ.0)GO TO 100
C  CALCULATES THE PART OF MATRIX COEFFICIENTS DEPENDING FROM
C  THE TENSION PARAMETER TP.
      TPQ=TP*TP
      TPQ60=TPQ/60.
      TPQ40=TPQ/40.
      TPQ15=TPQ/15.
        DO 80 I=1,N
          AL=0.
          BE=0.
          GA=0.
          Z1=0.
          Z2=0.
          JIN=NADVE(I)+1
          JFIN=NADVE(I+1)
            DO 70 J=JIN,JFIN
              K=INDEX(J)
              IND=IADVE(J)
              DZ=Z(I)-Z(IND)
              AL=AL+ALFA(K)*EIJQ(K)
              BE=BE+BETA(K)*EIJQ(K)
              GA=GA+GAMMA(K)*EIJQ(K)
              SQEIJQ=SQRT(EIJQ(K))
              Z1=Z1+(X(I)-X(IND))*DZ/SQEIJQ
              Z2=Z2+(Y(I)-Y(IND))*DZ/SQEIJQ
   70       CONTINUE
          ALFAS(I)=ALFAS(I)+TPQ15*AL
          BETAS(I)=BETAS(I)+TPQ15*BE
          GAMMAS(I)=GAMMAS(I)+TPQ15*GA
          ZX(I)=ZX(I)+TPQ40*Z1
          ZY(I)=ZY(I)+TPQ40*Z2
   80   CONTINUE
        M=NADVE(N+1)/2
          DO 90 I=1,M
            ALFA(I)=ALFA(I)-TPQ60*ALFA(I)*EIJQ(I)
            BETA(I)=BETA(I)-TPQ60*BETA(I)*EIJQ(I)
            GAMMA(I)=GAMMA(I)-TPQ60*GAMMA(I)*EIJQ(I)
   90     CONTINUE
C  CALCULATES THE SOLUTIONS OF THE SYSTEM FOLLOWING THE GAUSS-SIEDEL
C  METHOD.
  100 ITER=1
      TAU=RELER*PDM+2*N*SRELPR
  110 ERQ=0.
        DO 130 I=1,N
        ADX=0.
        BDX=0.
        BDY=0.
        GDY=0.
        JIN=NADVE(I)+1
        JFIN=NADVE(I+1)
          DO 120 J=JIN,JFIN
            IND=2*IADVE(J)
            K=INDEX(J)
            ADX=ADX+ALFA(K)*PD(IND-1)
            BDY=BDY+BETA(K)*PD(IND)
            BDX=BDX+BETA(K)*PD(IND-1)
            GDY=GDY+GAMMA(K)*PD(IND)
  120     CONTINUE
        DET=ALFAS(I)*GAMMAS(I)-BETAS(I)*BETAS(I)
        S1=ADX+BDY-ZX(I)
        S2=BDX+GDY-ZY(I)
        PDXN=(-GAMMAS(I)*S1+BETAS(I)*S2)/DET
        PDYN=(BETAS(I)*S1-ALFAS(I)*S2)/DET
        IPI=I+I
        ERX=PDXN-PD(IPI-1)
        ERY=PDYN-PD(IPI)
        ERQ=ERQ+ERX*ERX+ERY*ERY
        PD(IPI-1)=PDXN
        PD(IPI)=PDYN
  130 CONTINUE
C  CHECKS WHETHER CONVERGENCE IS REACHED WITH THE PRESCRIBED TOLERANCE.
      IF(ERQ.LT.TAU)RETURN
        IF(ITER.EQ.20)GO TO 150
          ITER=ITER+1
          GO TO 110
C
C  ERROR EXIT.
  150 WRITE(NOUT,1)
      RETURN
    1 FORMAT(1X,26HMINIMIZATION NOT COMPLETED)
      END
      SUBROUTINE CTANG(NDP,XD,YD,NOUT,NT,IPT,IPL,IWL,IWP,WK)
C IT CARRIES OUT TRIANGULATION BY DIVIDING THE X-Y PLANE INTO A
C NUMBER OF TRIANGLES ACCORDING TO THE GIVEN DATA POINTS IN THE PLANE.
C AT THE END OF THE OPERATIONS,THE INDICES OF THE VERTEXES OF THE
C TRIANGLES ARE LISTED COUNTER-CLOCKWISE.
C SUBROUTINE CTANG CALLS THE MAXMN FUNCTION.
C
C
C THE INPUT PARAMETERS ARE
C     NDP = NUMBER OF DATA POINTS,
C     XD  = ARRAY OF DIMENSION NDP CONTAINING THE X COORDINATES OF THE
C           DATA POINTS,
C     YD  = ARRAY OF DIMENSION NDP CONTAINING THE Y COORDINATES OF THE
C           DATA POINTS,
C     NOUT= LOGICAL UNIT NUMBER FOR THE STANDARD OUTPUT UNIT OF THE
C           SYSTEM.
C
C THE OUTPUT PARAMETERS ARE
C     NT  = NUMBER OF TRIANGLES,
C     IPT = INTEGER ARRAY OF DIMENSION 6*NDP-15, WHERE THE INDICES OF
C           THE VERTEXES OF THE (IT)TH TRIANGLE ARE TO BE STORED AS THE
C           (3*IT-2)ND, (3*IT-1)ST AND (3*IT)TH ELEMENTS, IT=1,2,..,NT.
C
C THE OTHER PARAMETERS ARE
C     IPL = INTEGER ARRAY OF DIMENSION 6*NDP USED INTERNALLY AS WORK
C           AREA,
C     IWL = INTEGER ARRAY OF DIMENSION 18*NDP USED INTERNALLY AS WORK
C           AREA,
C     IWP = INTEGER ARRAY OF DIMENSION NDP USED INTERNALLY AS WORK
C           AREA,
C     WK  = ARRAY OF DIMENSION NDP USED INTERNALLY AS WORK AREA.
C
C DECLARATION STATEMENTS.
      DIMENSION XD(*),YD(*),IPT(*),IPL(*),IWL(*),IWP(*),WK(*)
      DIMENSION ITF(2)
      DATA  RATIO/1.0E-6/, NREP/100/
C STATEMENT FUNCTIONS.
      DSQF(U1,V1,U2,V2)=(U2-U1)**2+(V2-V1)**2
      SIDE(U1,V1,U2,V2,U3,V3)=(V3-V1)*(U2-U1)-(U3-U1)*(V2-V1)
C PRELIMINARY PROCESSING.
   10 NDP0=NDP
      NDPM1=NDP0-1
      IF(NDP0.LT.4)       GO TO 90
C DETERMINES THE CLOSEST PAIR OF DATA POINTS AND THEIR MIDPOINTS.
   20 DSQMN=DSQF(XD(1),YD(1),XD(2),YD(2))
      IPMN1=1
      IPMN2=2
      DO 22  IP1=1,NDPM1
        X1=XD(IP1)
        Y1=YD(IP1)
        IP1P1=IP1+1
        DO 21  IP2=IP1P1,NDP0
          DSQI=DSQF(X1,Y1,XD(IP2),YD(IP2))
          IF(DSQI.EQ.0.0)GO TO 91
          IF(DSQI.GE.DSQMN)GO TO 21
          DSQMN=DSQI
          IPMN1=IP1
          IPMN2=IP2
   21   CONTINUE
   22 CONTINUE
      DSQ12=DSQMN
      XDMP=(XD(IPMN1)+XD(IPMN2))/2.0
      YDMP=(YD(IPMN1)+YD(IPMN2))/2.0
C SORTS THE OTHER (NDP-2) DATA POINTS IN ASCENDING ORDER OF DISTANCE
C FROM THE MIDPOINTS AND STORES THE STORED DATA POINTS NUMBERS IN THE
C IWP ARRAY.
   30 JP1=2
      DO 31  IP1=1,NDP0
        IF(IP1.EQ.IPMN1.OR.IP1.EQ.IPMN2)      GO TO 31
        JP1=JP1+1
        IWP(JP1)=IP1
        WK(JP1)=DSQF(XDMP,YDMP,XD(IP1),YD(IP1))
   31 CONTINUE
      DO 33  JP1=3,NDPM1
        DSQMN=WK(JP1)
        JPMN=JP1
        DO 32  JP2=JP1,NDP0
          IF(WK(JP2).GE.DSQMN)      GO TO 32
          DSQMN=WK(JP2)
          JPMN=JP2
   32   CONTINUE
        ITS=IWP(JP1)
        IWP(JP1)=IWP(JPMN)
        IWP(JPMN)=ITS
        WK(JPMN)=WK(JP1)
   33 CONTINUE
C IF NECESSARY, MODIFIES THE ORDERING SO THAT THE
C FIRST THREE DATA POINTS ARE NOT COLLINEAR.
   35 AR=DSQ12*RATIO
      X1=XD(IPMN1)
      Y1=YD(IPMN1)
      DX21=XD(IPMN2)-X1
      DY21=YD(IPMN2)-Y1
      DO 36  JP=3,NDP0
        IP=IWP(JP)
        IF(ABS((YD(IP)-Y1)*DX21-(XD(IP)-X1)*DY21).GT.AR)
     1               GO TO 37
   36 CONTINUE
      GO TO 92
   37 IF(JP.EQ.3)    GO TO 40
      JPMX=JP
      JP=JPMX+1
      DO 38  JPC=4,JPMX
        JP=JP-1
        IWP(JP)=IWP(JP-1)
   38 CONTINUE
      IWP(3)=IP
C FORMS THE FIRST TRIANGLE, STORES POINT NUMBERS OF THE VERTEXES OF
C THE TRIANGLES IN THE IPT ARRAY, AND STORES POINT NUMBERS OF THE
C BORDER LINE SEGMENTS AND THE TRIANGLE NUMBER IN THE IPL ARRAY.
   40 IP1=IPMN1
      IP2=IPMN2
      IP3=IWP(3)
      IF(SIDE(XD(IP1),YD(IP1),XD(IP2),YD(IP2),XD(IP3),YD(IP3))
     1     .GE.0.0)       GO TO 41
      IP1=IPMN2
      IP2=IPMN1
   41 NT0=1
      NTT3=3
      IPT(1)=IP1
      IPT(2)=IP2
      IPT(3)=IP3
      NL0=3
      NLT3=9
      IPL(1)=IP1
      IPL(2)=IP2
      IPL(3)=1
      IPL(4)=IP2
      IPL(5)=IP3
      IPL(6)=1
      IPL(7)=IP3
      IPL(8)=IP1
      IPL(9)=1
C ADDS THE REMAINING (NDP-3) DATA POINTS, ONE BY ONE.
   50 DO 79  JP1=4,NDP0
        IP1=IWP(JP1)
        X1=XD(IP1)
        Y1=YD(IP1)
C DETERMINES THE VISIBLE LINE SEGMENTS.
        IP2=IPL(1)
        JPMN=1
        DXMN=XD(IP2)-X1
        DYMN=YD(IP2)-Y1
        DSQMN=DXMN**2+DYMN**2
        ARMN=DSQMN*RATIO
        JPMX=1
        DXMX=DXMN
        DYMX=DYMN
        DSQMX=DSQMN
        ARMX=ARMN
        DO 52  JP2=2,NL0
          IP2=IPL(3*JP2-2)
          DX=XD(IP2)-X1
          DY=YD(IP2)-Y1
          AR=DY*DXMN-DX*DYMN
          IF(AR.GT.ARMN)       GO TO 51
          DSQI=DX**2+DY**2
          IF(AR.GE.(-ARMN).AND.DSQI.GE.DSQMN)      GO TO 51
          JPMN=JP2
          DXMN=DX
          DYMN=DY
          DSQMN=DSQI
          ARMN=DSQMN*RATIO
   51     AR=DY*DXMX-DX*DYMX
          IF(AR.LT.(-ARMX))    GO TO 52
          DSQI=DX**2+DY**2
          IF(AR.LE.ARMX.AND.DSQI.GE.DSQMX)    GO TO 52
          JPMX=JP2
          DXMX=DX
          DYMX=DY
          DSQMX=DSQI
          ARMX=DSQMX*RATIO
   52   CONTINUE
        IF(JPMX.LT.JPMN)  JPMX=JPMX+NL0
        NSH=JPMN-1
        IF(NSH.LE.0)      GO TO 60
C SHIFTS (ROTATES) THE IPL ARRAY SO THAT THE INVISIBLE BORDER LINE
C SEGMENTS ARE CONTAINED IN THE FIRST PART OF THE IPL ARRAY.
        NSHT3=NSH*3
        DO 53  JP2T3=3,NSHT3,3
          JP3T3=JP2T3+NLT3
          IPL(JP3T3-2)=IPL(JP2T3-2)
          IPL(JP3T3-1)=IPL(JP2T3-1)
          IPL(JP3T3)  =IPL(JP2T3)
   53   CONTINUE
        DO 54  JP2T3=3,NLT3,3
          JP3T3=JP2T3+NSHT3
          IPL(JP2T3-2)=IPL(JP3T3-2)
          IPL(JP2T3-1)=IPL(JP3T3-1)
          IPL(JP2T3)  =IPL(JP3T3)
   54   CONTINUE
        JPMX=JPMX-NSH
C ADDS TRIANGLES TO THE IPT ARRAY, UPDATES BORDER LINE SEGMENTS IN
C THE IPL ARRAY, AND SETS FLAGS FOR THE BORDER LINE SEGMENTS TO BE
C REEXAMINED IN THE IWL ARRAY.
   60   JWL=0
        DO 64  JP2=JPMX,NL0
          JP2T3=JP2*3
          IPL1=IPL(JP2T3-2)
          IPL2=IPL(JP2T3-1)
          IT  =IPL(JP2T3)
C ADDS A TRIANGLE TO THE IPT ARRAY.
          NT0=NT0+1
          NTT3=NTT3+3
          IPT(NTT3-2)=IPL2
          IPT(NTT3-1)=IPL1
          IPT(NTT3)  =IP1
C UPDATES THE BORDER LINE SEGMENTS IN THE IPL ARRAY.
          IF(JP2.NE.JPMX)      GO TO 61
          IPL(JP2T3-1)=IP1
          IPL(JP2T3)  =NT0
   61     IF(JP2.NE.NL0)       GO TO 62
          NLN=JPMX+1
          NLNT3=NLN*3
          IPL(NLNT3-2)=IP1
          IPL(NLNT3-1)=IPL(1)
          IPL(NLNT3)  =NT0
C DETERMINES THE VERTEX THAT DOES NOT LIE ON THE BORDER LINE SEGMENTS.
   62     ITT3=IT*3
          IPTI=IPT(ITT3-2)
          IF(IPTI.NE.IPL1.AND.IPTI.NE.IPL2)   GO TO 63
          IPTI=IPT(ITT3-1)
          IF(IPTI.NE.IPL1.AND.IPTI.NE.IPL2)   GO TO 63
          IPTI=IPT(ITT3)
C CHECKS WHETHER THE EXCHANGE IS NECESSARY.
   63     IF(MAXMN(XD,YD,IP1,IPTI,IPL1,IPL2).EQ.0)     GO TO 64
C MODIFIES THE IPT ARRAY WHEN NECESSARY.
          IPT(ITT3-2)=IPTI
          IPT(ITT3-1)=IPL1
          IPT(ITT3)  =IP1
          IPT(NTT3-1)=IPTI
          IF(JP2.EQ.JPMX)      IPL(JP2T3)=IT
          IF(JP2.EQ.NL0.AND.IPL(3).EQ.IT)     IPL(3)=NT0
C SETS FLAGS IN THE IWL ARRAY.
          JWL=JWL+4
          IWL(JWL-3)=IPL1
          IWL(JWL-2)=IPTI
          IWL(JWL-1)=IPTI
          IWL(JWL)  =IPL2
   64   CONTINUE
        NL0=NLN
        NLT3=NLNT3
        NLF=JWL/2
        IF(NLF.EQ.0)      GO TO 79
C IMPROVES THE TRIANGULATION.
   70   NTT3P3=NTT3+3
        DO 78  IREP=1,NREP
          DO 76  ILF=1,NLF
            ILFT2=ILF*2
            IPL1=IWL(ILFT2-1)
            IPL2=IWL(ILFT2)
C LOCATES IN THE IPT ARRAY TWO TRIANGLES ON BOTH SIDES OF THE
C FLAGGED LINE SEGMENT.
            NTF=0
            DO 71  ITT3R=3,NTT3,3
              ITT3=NTT3P3-ITT3R
              IPT1=IPT(ITT3-2)
              IPT2=IPT(ITT3-1)
              IPT3=IPT(ITT3)
              IF(IPL1.NE.IPT1.AND.IPL1.NE.IPT2.AND.
     1           IPL1.NE.IPT3)      GO TO 71
              IF(IPL2.NE.IPT1.AND.IPL2.NE.IPT2.AND.
     1           IPL2.NE.IPT3)      GO TO 71
              NTF=NTF+1
              ITF(NTF)=ITT3/3
              IF(NTF.EQ.2)     GO TO 72
   71       CONTINUE
            IF(NTF.LT.2)       GO TO 76
C DETERMINES THE VERTEXES OF THE TRIANGLES THAT DO NOT LIE ON THE
C LINE SEGMENT.
   72       IT1T3=ITF(1)*3
            IPTI1=IPT(IT1T3-2)
            IF(IPTI1.NE.IPL1.AND.IPTI1.NE.IPL2)    GO TO 73
            IPTI1=IPT(IT1T3-1)
            IF(IPTI1.NE.IPL1.AND.IPTI1.NE.IPL2)    GO TO 73
            IPTI1=IPT(IT1T3)
   73       IT2T3=ITF(2)*3
            IPTI2=IPT(IT2T3-2)
            IF(IPTI2.NE.IPL1.AND.IPTI2.NE.IPL2)    GO TO 74
            IPTI2=IPT(IT2T3-1)
            IF(IPTI2.NE.IPL1.AND.IPTI2.NE.IPL2)    GO TO 74
            IPTI2=IPT(IT2T3)
C CHECKS WHETHER THE EXCHANGE IS NECESSARY.
   74 IF(MAXMN(XD,YD,IPTI1,IPTI2,IPL1,IPL2).EQ.0)
     1         GO TO 76
C MODIFIES THE IPT ARRAY WHEN NECESSARY.
            IPT(IT1T3-2)=IPTI1
            IPT(IT1T3-1)=IPTI2
            IPT(IT1T3)  =IPL1
            IPT(IT2T3-2)=IPTI2
            IPT(IT2T3-1)=IPTI1
            IPT(IT2T3)  =IPL2
C SETS NEW FLAGS.
            JWL=JWL+8
            IWL(JWL-7)=IPL1
            IWL(JWL-6)=IPTI1
            IWL(JWL-5)=IPTI1
            IWL(JWL-4)=IPL2
            IWL(JWL-3)=IPL2
            IWL(JWL-2)=IPTI2
            IWL(JWL-1)=IPTI2
            IWL(JWL)  =IPL1
            DO 75  JLT3=3,NLT3,3
              IPLJ1=IPL(JLT3-2)
              IPLJ2=IPL(JLT3-1)
              IF((IPLJ1.EQ.IPL1.AND.IPLJ2.EQ.IPTI2).OR.
     1           (IPLJ2.EQ.IPL1.AND.IPLJ1.EQ.IPTI2))
     2                         IPL(JLT3)=ITF(1)
              IF((IPLJ1.EQ.IPL2.AND.IPLJ2.EQ.IPTI1).OR.
     1           (IPLJ2.EQ.IPL2.AND.IPLJ1.EQ.IPTI1))
     2                         IPL(JLT3)=ITF(2)
   75       CONTINUE
   76     CONTINUE
          NLFC=NLF
          NLF=JWL/2
          IF(NLF.EQ.NLFC)      GO TO 79
C RESETS THE IWL ARRAY FOR THE NEXT ROUND.
          JWL=0
          JWL1MN=(NLFC+1)*2
          NLFT2=NLF*2
          DO 77  JWL1=JWL1MN,NLFT2,2
            JWL=JWL+2
            IWL(JWL-1)=IWL(JWL1-1)
            IWL(JWL)  =IWL(JWL1)
   77     CONTINUE
          NLF=JWL/2
   78   CONTINUE
   79 CONTINUE
C REARRANGES THE IPT ARRAY SO THAT THE VERTEXES OF EACH TRIANGLE ARE
C LISTED COUNTER-CLOCKWISE.
   80 DO 81  ITT3=3,NTT3,3
        IP1=IPT(ITT3-2)
        IP2=IPT(ITT3-1)
        IP3=IPT(ITT3)
        IF(SIDE(XD(IP1),YD(IP1),XD(IP2),YD(IP2),XD(IP3),YD(IP3))
     1       .GE.0.0)     GO TO 81
        IPT(ITT3-2)=IP2
        IPT(ITT3-1)=IP1
   81 CONTINUE
      NT=NT0
      RETURN
C
C ERROR EXIT.
   90 WRITE (NOUT,2090) NDP0
      GO TO 93
   91 WRITE (NOUT,2091) NDP0,IP1,IP2,X1,Y1
      GO TO 93
   92 WRITE (NOUT,2092) NDP0
   93 WRITE (NOUT,2093)
      NT=0
      STOP
C FORMAT STATEMENTS.
 2090 FORMAT(1X/23H ***   NDP LESS THAN 4./7H  NDP =,I5)
 2091 FORMAT(1X/29H ***   IDENTICAL DATA POINTS./
     1       7H  NDP =,I5,5X,5HIP1 =,I5,5X,5HIP2 =,
     2       I5,5X,4HXD =,E12.4,5X,4HYD =,E12.4)
 2092 FORMAT(1X/33H ***   ALL COLLINEAR DATA POINTS./
     1       7H  NDP =,I5)
 2093 FORMAT(35H ERROR DETECTED IN ROUTINE    CTANG)
      END
      SUBROUTINE ORDGR(XD,YD,NT,IPT,NXI,NYI,XI,YI,NGP,IGP)
C IT ORGANIZES GRID POINTS FOR SURFACE RECONSTRUCTION BY
C SORTING THEM ACCORDING TO THEIR BELONGING TO THE TRIANGLES.
C
C THE INPUT PARAMETERS ARE
C     XD,YD = ARRAY OF DIMENSION N CONTAINING THE X AND Y COORDINATES
C             OF THE DATA POINTS, WHERE N IS THE NUMBER OF THE DATA
C             POINTS,
C     NT  = NUMBER OF TRIANGLES,
C     IPT = INTEGER ARRAY OF DIMENSION 3*NT CONTAINING THE INDICES OF
C           THE VERTEXES OF THE TRIANGLES,
C     NXI = NUMBER OF GRID POINTS IN THE X COORDINATES,
C     NYI = NUMBER OF GRID POINTS IN THE Y COORDINATES,
C     XI,YI = ARRAY OF DIMENSION NXI AND NYI CONTAINING THE X AND Y
C             COORDINATES OF THE GRID POINTS,RESPECTIVELY.
C
C THE OUTPUT PARAMETERS ARE
C     NGP = INTEGER ARRAY OF DIMENSION 2*NT WHERE THE NUMBER OF GRID
C           POINTS BELONGING TO EACH TRIANGLE IS TO BE STORED,
C     IGP = INTEGER ARRAY OF DIMENSION NXI*NYI WHERE THE INDICES OF THE
C           GRID POINTS ARE TO BE STORED ACCORDING TO THEIR BELONGING
C           TO THE TRIANGLES CONSIDERED IN ASCENDING ORDER NUMBERS.
C
C DECLARATION STATEMENT.
C
      DIMENSION XD(*),YD(*),IPT(*),XI(*),YI(*),NGP(*),IGP(*)
C
C STATEMENT FUNCTION.
      SIDE(U1,V1,U2,V2,U3,V3) = (U1-U3)*(V2-V3)-(V1-V3)*(U2-U3)
      NT0 = NT
C
C PRELIMINARY PROCESSING.
      NXI0 = NXI
      NYI0 = NYI
      NXINYI = NXI0*NYI0
C
C DETERMINES GRID POINTS INSIDE THE DATA AREA.
      JNGP0 = 0
      JNGP1 = 2*NT0 + 1
      JIGP0 = 0
      JIGP1 = NXINYI + 1
      DO 160 IT0=1,NT0
        NGP0 = 0
        NGP1 = 0
        IT0T3 = IT0*3
        IP1 = IPT(IT0T3-2)
        IP2 = IPT(IT0T3-1)
        IP3 = IPT(IT0T3)
        X1 = XD(IP1)
        Y1 = YD(IP1)
        X2 = XD(IP2)
        Y2 = YD(IP2)
        X3 = XD(IP3)
        Y3 = YD(IP3)
        XMN = AMIN1(X1,X2,X3)
        XMX = AMAX1(X1,X2,X3)
        YMN = AMIN1(Y1,Y2,Y3)
        YMX = AMAX1(Y1,Y2,Y3)
        INSD = 0
        DO 20 IXI=1,NXI0
          IF (XI(IXI).GE.XMN .AND. XI(IXI).LE.XMX) GO TO 10
          IF (INSD.EQ.0) GO TO 20
          IXIMX = IXI - 1
          GO TO 30
   10     IF (INSD.EQ.1) GO TO 20
          INSD = 1
          IXIMN = IXI
   20   CONTINUE
        IF (INSD.EQ.0) GO TO 150
        IXIMX = NXI0
   30   DO 140 IYI=1,NYI0
          YII = YI(IYI)
          IF (YII.LT.YMN .OR. YII.GT.YMX) GO TO 140
          DO 130 IXI=IXIMN,IXIMX
            XII = XI(IXI)
            L = 0
            IF (SIDE(X1,Y1,X2,Y2,XII,YII)) 130, 40, 50
   40       L = 1
   50       IF (SIDE(X2,Y2,X3,Y3,XII,YII)) 130, 60, 70
   60       L = 1
   70       IF (SIDE(X3,Y3,X1,Y1,XII,YII)) 130, 80, 90
   80       L = 1
   90       IZI = NXI0*(IYI-1) + IXI
            IF (L.EQ.1) GO TO 100
            NGP0 = NGP0 + 1
            JIGP0 = JIGP0 + 1
            IGP(JIGP0) = IZI
            GO TO 130
  100       IF (JIGP1.GT.NXINYI) GO TO 120
            DO 110 JIGP1I=JIGP1,NXINYI
              IF (IZI.EQ.IGP(JIGP1I)) GO TO 130
  110       CONTINUE
  120       NGP1 = NGP1 + 1
            JIGP1 = JIGP1 - 1
            IGP(JIGP1) = IZI
  130     CONTINUE
  140   CONTINUE
  150   JNGP0 = JNGP0 + 1
        NGP(JNGP0) = NGP0
        JNGP1 = JNGP1 - 1
        NGP(JNGP1) = NGP1
  160 CONTINUE
      RETURN
      END
      FUNCTION MAXMN(X,Y,I1,I2,I3,I4)
C IT DETERMINES WHETHER THE EXCHANGE OF TWO TRIANGLES IS NECESSARY
C OR NOT ON THE BASIS OF THE MAX-MIN-ANGLE CRITERION BY C.LAWSON.
C
C THE INPUT PARAMETERS ARE
C     X,Y = ARRAYS CONTAINING THE COORDINATES OF THE DATA POINTS,
C     I1,I2,I3,I4 = POINT NUMBERS OF FOUR POINTS P1,P2,P3 AND P4
C                   FORMING A QUADRILATERAL WITH P3 AND P4
C                   DIAGONALLY CONNECTED.
C
C FUNCTION MAXMN RETURNS AN INTEGER VALUE 1 (ONE) WHEN AN EXCHANGE IS
C NECESSARY, OTHERWISE 0 (ZERO).
C
C DECLARATION STATEMENT.
      DIMENSION X(*),Y(*)
      EQUIVALENCE (C2SQ,C1SQ),(A3SQ,B2SQ),(B3SQ,A1SQ),
     1            (A4SQ,B1SQ),(B4SQ,A2SQ),(C4SQ,C3SQ)
C PRELIMINARY PROCESSING.
      X1=X(I1)
      Y1=Y(I1)
      X2=X(I2)
      Y2=Y(I2)
      X3=X(I3)
      Y3=Y(I3)
      X4=X(I4)
      Y4=Y(I4)
C CALCULATION.
      IDX=0
      U3=(Y2-Y3)*(X1-X3)-(X2-X3)*(Y1-Y3)
      U4=(Y1-Y4)*(X2-X4)-(X1-X4)*(Y2-Y4)
      IF(U3*U4.LE.0.0)GO TO 10
      U1=(Y3-Y1)*(X4-X1)-(X3-X1)*(Y4-Y1)
      U2=(Y4-Y2)*(X3-X2)-(X4-X2)*(Y3-Y2)
      A1SQ=(X1-X3)**2+(Y1-Y3)**2
      B1SQ=(X4-X1)**2+(Y4-Y1)**2
      C1SQ=(X3-X4)**2+(Y3-Y4)**2
      A2SQ=(X2-X4)**2+(Y2-Y4)**2
      B2SQ=(X3-X2)**2+(Y3-Y2)**2
      C3SQ=(X2-X1)**2+(Y2-Y1)**2
      S1SQ=U1*U1/(C1SQ*AMAX1(A1SQ,B1SQ))
      S2SQ=U2*U2/(C2SQ*AMAX1(A2SQ,B2SQ))
      S3SQ=U3*U3/(C3SQ*AMAX1(A3SQ,B3SQ))
      S4SQ=U4*U4/(C4SQ*AMAX1(A4SQ,B4SQ))
      IF(AMIN1(S1SQ,S2SQ).LT.AMIN1(S3SQ,S4SQ))IDX=1
   10 MAXMN=IDX
      RETURN
      END
      SUBROUTINE ADJAC(NT,IPT,N,IADVE,NADVE)
C IT ESTIMATES THE ADJACENCIES MONODIMENSIONAL ARRAY CONTAINING
C FOR EACH VERTEX THE INDICES OF THE VERTEXES ADJACENT IN THE
C TRIANGULATION.
C
C THE INPUT PARAMETERS ARE
C     NT  = NUMBER OF TRIANGLES,
C     IPT = INTEGER ARRAY OF DIMENSION 3*NT CONTAINING THE INDICES
C           OF THE VERTEXES OF THE TRIANGLES,
C     N   = NUMBER OF DATA POINTS.
C
C THE OUTPUT PARAMETERS ARE
C     IADVE = INTEGER ARRAY OF DIMENSION  6*N-12  CONTAINING FOR EACH
C             VERTEX THE INDICES OF THE VERTEXES ADJACENT IN THE
C             TRIANGULATION,
C     NADVE = INTEGER ARRAY OF DIMENSION  N+1  CONTAINING FOR EACH
C             VERTEX THE NUMBER OF THE VERTEXES ADJACENT IN THE
C             TRIANGULATION.
C
C  DECLARATION STATEMENT.
      DIMENSION IPT(*),IADVE(*),NADVE(*),ITEM(30)
      NADVE(1)=0
      KIN=0
      NT3=3*NT
        DO 70 I=1,N
          I2=0
C  STORES THE INDICES OF THE ADJACENT VERTEXES.
          DO 30 J1=1,NT3,3
            J2=J1+2
            DO 10 J=J1,J2
              IF(I.EQ.IPT(J))GO TO 20
   10       CONTINUE
          GO TO 30
   20       I1=I2+1
            I2=I2+2
            ITEM(I1)=IPT(J1+MOD(J,3))
            ITEM(I2)=IPT(J1+MOD(J+1,3))
   30     CONTINUE
C  DISCARDS THE INDICES THAT HAVE BEEN STORED TWICE.
          JIN=KIN+1
          KIN=KIN+2
          JFIN=KIN
          IADVE(JIN)=ITEM(1)
          IADVE(JFIN)=ITEM(2)
            IF(I2.EQ.2)GO TO 60
              DO 50 J=3,I2
                DO 40 L=JIN,JFIN
                  IF(ITEM(J).EQ.IADVE(L))GO TO 50
   40           CONTINUE
                KIN=KIN+1
                IADVE(KIN)=ITEM(J)
                JFIN=KIN
   50         CONTINUE
   60       NADVE(I+1)=KIN
   70   CONTINUE
      RETURN
      END
      SUBROUTINE MACEPS(SRELPR)
C IT CARRIES OUT AN APPROXIMATION OF THE SINGLE RELATIVE PRECISION
C CONSTANT
      SRELPR=1.0
10    SRELPR=0.5*SRELPR
C THE DO LOOP STATEMENT IS NECESSARY WHEN THE ARITHMETIC UNIT HAS MORE
C BITS THAN IN STORAGE (INTEL 8087 FAMILY OF ARITHMETIC UNITS IS OF
C THIS TYPE), INFACT A DO LOOP INVOLVES A STORE FROM REGISTER TO MEMORY
C OF THE VALUE FOR SRELPR.
      DO 20 I=1,2
20    CONTINUE
      IF (SRELPR+1.0.GT.1.0) GOTO 10
      SRELPR=2.0*SRELPR
      RETURN
      END
      SUBROUTINE MMERR(NXI,NYI,ZI,ZI1,NDIM,ERMAX,ERMEAN)
C IT CARRIES OUT MAX ERROR AND MEAN ERROR AT PRESCRIBED RECTANGULAR
C GRID POINTS OF THE RECONSTRUCTED SURFACE.
C
C THE INPUT PARAMETERS ARE
C     NXI = NUMBER OF OUTPUT GRID POINTS IN THE X COORDINATE (MUST BE
C           1 OR GREATER),
C     NYI = NUMBER OF OUTPUT GRID POINTS IN THE Y COORDINATE (MUST BE
C           1 OR GREATER),
C     ZI  = DOUBLY-DIMENSIONED ARRAY OF DIMENSION NXI*NYI, WHERE THE
C           ANALYTIC  Z  VALUES AT THE OUTPUT GRID POINTS ARE TO
C           BE STORED.
C     ZI1 = DOUBLY-DIMENSIONED ARRAY OF DIMENSION NXI*NYI, WHERE THE
C           INTERPOLATED  Z  VALUES AT THE OUTPUT GRID POINTS ARE TO
C           BE STORED.
C     NDIM= DECLARED ROW DIMENSION OF THE ARRAYS ZI AND ZI1.
C
C THE OUTPUT PARAMETERS ARE
C     ERMAX = MAX ERROR
C     ERMEAN= MEAN ERROR
C
      DIMENSION ZI(NDIM,*),ZI1(NDIM,*)
      ERMAX=0.0
      SUM=0.0
      N=0
      DO 10 I=1,NXI
        DO 10 J=1,NYI
          IF (ZI1(I,J).EQ.1.E6) GOTO 10
          N=N+1
          ERR=ABS(ZI(I,J)-ZI1(I,J))
          SUM=SUM+ERR
          IF (ERR.GT.ERMAX) ERMAX=ERR
10    CONTINUE
      ERMEAN=SUM/FLOAT(N)
      RETURN
      END
      SUBROUTINE PDSTE(N,X,Y,Z,NT,IPT,PD,IPD)
C IT ESTIMATES THE FIRST ORDER PARTIAL DERIVATIVE VALUES
C AT THE DATA POINTS FOLLOWING THE KLUCEWICZ METHOD.
C
C THE INPUT PARAMETERS ARE
C     N   = NUMBER OF DATA POINTS,
C     X,Y,Z = ARRAYS OF DIMENSION N CONTAINING THE X,Y AND Z
C             COORDINATES OF THE DATA POINTS,
C     NT  = NUMBER OF TRIANGLES,
C     IPT = INTEGER ARRAY OF DIMENSION 3*NT CONTAINING THE INDICES
C           OF THE VERTEXES OF THE TRIANGLES.
C
C THE OUTPUT PARAMETER IS
C     PD  = ARRAY OF DIMENSION 2*N CONTAINING THE PARTIAL DERIVATIVE
C           VALUES AT THE DATA POINTS.
C
C THE OTHER PARAMETER IS
C     IPD = INTEGER ARRAY OF DIMENSION N USED INTERNALLY AS WORK AREA.
C
C DECLARATION STATEMENT.
      DIMENSION X(*),Y(*),Z(*),IPT(*),PD(*),IPD(*)
C PRELIMINARY PROCESSING.
      N2=N+N
        DO 10 I=1,N2
          PD(I)=0.
          IPD(I)=0
10      CONTINUE
C ESTIMATES FOR EACH TRIANGLE THE SLOPES OF THE PLANE THROUGH THE
C FUNCTION'S VALUE AT THE VERTEXES.
      DO 20 I=1,NT
        L=3*I
        I1=IPT(L-2)
        I2=IPT(L-1)
        I3=IPT(L)
        X21=X(I2)-X(I1)
        X31=X(I3)-X(I1)
        Y21=Y(I2)-Y(I1)
        Y31=Y(I3)-Y(I1)
        Z21=Z(I2)-Z(I1)
        Z31=Z(I3)-Z(I1)
        C=Y21*X31-X21*Y31
        DX=(Y21*Z31-Z21*Y31)/C
        DY=(Z21*X31-X21*Z31)/C
C  UPDATES THE IPD AND PD ARRAYS.
        IPD(I1)=IPD(I1)+1
        I1=I1+I1
        PD(I1-1)=PD(I1-1)+DX
        PD(I1)=PD(I1)+DY
        IPD(I2)=IPD(I2)+1
        I2=I2+I2
        PD(I2-1)=PD(I2-1)+DX
        PD(I2)=PD(I2)+DY
        IPD(I3)=IPD(I3)+1
        I3=I3+I3
        PD(I3-1)=PD(I3-1)+DX
        PD(I3)=PD(I3)+DY
20    CONTINUE
C  AVERAGES THE DERIVATIVE VALUES STORED IN THE PD ARRAY.
      J=0
        DO 30 I=2,N2,2
          J=J+1
          DEN=IPD(J)
          PD(I-1)=PD(I-1)/DEN
          PD(I)=PD(I)/DEN
30      CONTINUE
      RETURN
      END
      SUBROUTINE INTRP(SRELPR,TOL,X,Y,Z,IPT,PD,ITI,ITPV,XII,YII,ZII)
C IT CARRIES OUT PUNCTUAL INTERPOLATION, I.E., IT DETERMINES
C THE Z VALUE AT A GIVEN POINT IN A TRIANGLE BY MEANS OF THE
C 9-PARAMETER DISCRETIZED VERSION OF NIELSON'S SCHEME.
C
C THE INPUT PARAMETERS ARE
C    SRELPR,TOL = SINGLE RELATIVE PRECISION AND TOLERANCE,
C    X,Y,Z= ARRAYS OF DIMENSION N CONTAINING THE X,Y AND Z COORDINATES
C         OF THE DATA POINTS, WHERE N IS THE NUMBER OF THE DATA POINTS,
C    IPT = INTEGER ARRAY OF DIMENSION 3*NT, WHERE NT IS THE NUMBER OF
C          TRIANGLES, CONTAINING THE INDICES OF THE VERTEXES OF THE
C          TRIANGLES-THEMSELVES,
C    PD  = ARRAY OF DIMENSION 2*N CONTAINING THE PARTIAL DERIVATIVE
C          VALUES AT THE DATA POINTS,
C    ITI = INDEX OF THE TRIANGLE WHERE THE POINT FOR WHICH
C          INTERPOLATION HAS TO BE PERFORMED, LIES,
C    ITPV= INDEX OF THE TRIANGLE CONSIDERED IN THE PREVIOUS CALL,
C    XII,YII = X AND Y COORDINATES OF THE POINT FOR WHICH INTER-
C              POLATION HAS TO BE PERFORMED.
C
C THE OUTPUT PARAMETER IS
C    ZII = INTERPOLATED Z VALUE.
C
C DECLARATION STATEMENTS.
      DIMENSION X(*),Y(*),Z(*),IPT(*),PD(*)
      SAVE
      ITO=ITI
        IF(ITO.EQ.ITPV)GO TO 10
C  SELECTS THE TRIANGLE CONTAINING THE POINT (XII,YII).
          ITPV=ITO
          ITO3=3*ITO
          IND1=IPT(ITO3-2)
          IND2=IPT(ITO3-1)
          IND3=IPT(ITO3)
C  CALCULATES THE BASIC QUANTITIES RELATIVES TO THE SELECTED TRIANGLE.
          X12=X(IND1)-X(IND2)
          X13=X(IND1)-X(IND3)
          X23=X(IND2)-X(IND3)
          Y12=Y(IND1)-Y(IND2)
          Y13=Y(IND1)-Y(IND3)
          Y23=Y(IND2)-Y(IND3)
          D=X13*Y23-X23*Y13
          INDEX=2*IND1
          D3V1=-X13*PD(INDEX-1)-Y13*PD(INDEX)
          D2V1=-X12*PD(INDEX-1)-Y12*PD(INDEX)
          INDEX=2*IND2
          D1V2=X12*PD(INDEX-1)+Y12*PD(INDEX)
          D3V2=-X23*PD(INDEX-1)-Y23*PD(INDEX)
          INDEX=2*IND3
          D2V3=X23*PD(INDEX-1)+Y23*PD(INDEX)
          D1V3=X13*PD(INDEX-1)+Y13*PD(INDEX)
          E1=X23*X23+Y23*Y23
          E2=X13*X13+Y13*Y13
          E3=X12*X12+Y12*Y12
          E=2.*E1
          ALFA21=(E2+E1-E3)/E
          ALFA31=(E3+E1-E2)/E
          E=2.*E2
          ALFA12=(E1+E2-E3)/E
          ALFA32=(E3+E2-E1)/E
          E=2.*E3
          ALFA13=(E1+E3-E2)/E
          ALFA23=(E2+E3-E1)/E
C  CALCULATES THE REMAINING QUANTITIES NECESSARY FOR THE ZI EVALUATION
C  DEPENDING FROM THE INTERPOLATION POINT.
   10   B1=((XII-X(IND3))*Y23-(YII-Y(IND3))*X23)/D
        B2=((YII-Y(IND1))*X13-(XII-X(IND1))*Y13)/D
        B3=1.-B1-B2
          IF(B1.GE.TOL)GO TO 30
            IF(B2.GE.TOL)GO TO 40
              IF(B1+B2.LE.SRELPR)GO TO 50
        W=B1*B2*B3/(B1*B2+B1*B3+B2*B3)
        QB=B1*B1
        WB=W*B1
        ZII=Z(IND1)*(QB*(3.-2.*B1)+6.*WB*(B3*ALFA12+B2*ALFA13))+
     *      D3V1*(QB*B3+WB*(3.*B3*ALFA12+B2-B3))+
     *      D2V1*(QB*B2+WB*(3.*B2*ALFA13+B3-B2))
        QB=B2*B2
        WB=W*B2
        ZII=ZII+Z(IND2)*(QB*(3.-2.*B2)+6.*WB*(B1*ALFA23+B3*ALFA21))+
     *      D1V2*(QB*B1+WB*(3.*B1*ALFA23+B3-B1))+
     *      D3V2*(QB*B3+WB*(3.*B3*ALFA21+B1-B3))
        QB=B3*B3
        WB=W*B3
        ZII=ZII+Z(IND3)*(QB*(3.-2.*B3)+6.*WB*(B2*ALFA31+B1*ALFA32))+
     *      D2V3*(QB*B2+WB*(3.*B2*ALFA31+B1-B2))+
     *      D1V3*(QB*B1+WB*(3.*B1*ALFA32+B2-B1))
      RETURN
   30 ZII=Z(IND1)
      RETURN
   40 ZII=Z(IND2)
      RETURN
   50 ZII=Z(IND3)
      RETURN
      END
