From cb6d481a62183302d5c6d80706900d42ef7fa2eb Mon Sep 17 00:00:00 2001
From: Jerome Guterl <guterlj@fusion.gat.com>
Date: Thu, 22 Oct 2020 11:41:15 -0700
Subject: patch loglambda

---
 bbb/oderhs.m | 105 +++++++++++++++++++++------------------------------
 1 file changed, 44 insertions(+), 61 deletions(-)

diff --git a/bbb/oderhs.m b/bbb/oderhs.m
index 07cedba..3596e1f 100755
--- a/bbb/oderhs.m
+++ b/bbb/oderhs.m
@@ -684,15 +684,13 @@ cnxg      data igs/1/
       real radmc, svdiss, vyiy0, vyiym1, v2ix0, v2ixm1
       external rsa, rra, rqa, rcx, emissbs, erl1, erl2, radneq, radimpmc
       external radmc, svdiss
-      real tick,tock
-      external tick,tock
 	  
 ccc      save
 
 *  -- procedures --
       real ave, etaper, interp_yf, interp_xf
       ave(t0,t1) = 2*t0*t1 / (cutlo+t0+t1)
-      etaper(ix,iy) = 3.234e-9*lnlam/(max(te(ix,iy),temin*ev)
+      etaper(ix,iy) = 3.234e-9*loglambda(ix,iy)/(max(te(ix,iy),temin*ev)
      .                                          /(1000.*ev))**(1.5)
       interp_yf(ix,iy,t0,t1) = (t0*gy(ix,iy) + t1*gy(ix,iy+1)) /
      .                                       (gy(ix,iy)+gy(ix,iy+1))
@@ -1131,10 +1129,25 @@ c ,,, Add diffusion propto betap**iexpbp and (B0/B)**inbdif (as for isbohmcalc=3
 *  compute drifts
 *  ---------------------------------------------------------------------
 
+c ... Compute log_lambda
+      do iy = j1, j6
+        do ix = i1, i6
+          teev = te(ix,iy)/ev
+          if (islnlamcon == 1) then
+            loglambda(ix,iy) = lnlam  # set to constant
+          elseif (teev < 50.) then    # Braginskii formula, teev<50
+            loglambda(ix,iy) = 23.4-1.15*log10(1.e-6*ne(ix,iy))+
+     .                              3.45*log10(teev)
+          else                        #teev > 50
+            loglambda(ix,iy) = 25.3-1.15*log10(1.e-6*ne(ix,iy))+
+     .              2.33167537087122D+00*log10(teev)
+          endif
+          ctaui(ix,iy,1) = 2.1e13*sqrt(mi(1)/mp)/ loglambda(ix,iy)
+          ctaue(ix,iy,1) = 3.5e11/loglambda(ix,iy) #both for zi=1
+        enddo
+      enddo
 
 c ... Calculate collis. factors eta1 and rtaue for the simple Braginski model
-      ctaui = 2.1e13*sqrt(mi(1)/mp)/lnlam   # only for zi=1
-      ctaue = 3.5e11/lnlam                  # n_tau = ctaui,e*(Ti,e)**1.5
       do iy = j1, j6
         do ix = i1, i6
            eta1(ix,iy) = cfeta1*0.3*nm(ix,iy,1)*ti(ix,iy)*
@@ -1704,7 +1717,7 @@ c ..       switch to right plate(s)
             enddo
           enddo
         enddo
-      endif
+      endif         # checks if isimpon > 0
 
 ************************************************************************
 *     Calculate the currents fqx, fqy, fq2 and fqp, if isphion = 1
@@ -2620,11 +2633,10 @@ c
    41       continue
    42    continue
 
-         ctaui = 2.1e13 / (lnlam*zi(ifld)**2)
-         tv2 = ctaui / (ev * sqrt(ev))
-
          do 44 iy = j1, j6
             do 43 ix = i1, i6
+	       ctaui(ix,iy,ifld) = 2.1e13/(loglambda(ix,iy)*zi(ifld)**2) # mass fac?
+               tv2 = ctaui(ix,iy,ifld)/(ev*sqrt(ev))
                if (convis .eq. 0) then
                   a = max (ti(ix,iy), temin*ev)
                else
@@ -2737,15 +2749,14 @@ c...  Initialize w1 and w2 for each species
    51       continue
    52    continue
 
-         ctaue = 3.5e11 * zi(ifld) / lnlam
-         fxe = kxe * ce * ctaue / (me*ev*sqrt(ev))
-         ctaui = 2.1e13 / (lnlam*zi(ifld)**2)
-         fxi = kxi * ci * ctaui / (ev*sqrt(ev*mp))
-
          do 59 iy = j1, j6
             do 58 ix = i1, i6
                ix1 = ixp1(ix,iy)
                iyp1 = min(ny+1, iy+1)
+               ctaue(ix,iy,ifld) = 3.5e11*zi(ifld)/loglambda(ix,iy)
+               ctaui(ix,iy,ifld) =2.1e13/(loglambda(ix,iy)*zi(ifld)**2)
+               fxe = kxe * ce * ctaue(ix,iy,ifld) / (me*ev*sqrt(ev))
+               fxi = kxi * ci * ctaui(ix,iy,ifld) / (ev*sqrt(ev*mp))
                fxet = fxe
                fxit = fxi
                do jx = 1, nxpt  #reduce kxe inside sep by rkxecore fac
@@ -2944,10 +2955,8 @@ c          Now for the radial flux limit - good for nonorthog grid too
                lmfpn = 1./(sigcx * (niavey + rnn2cx*noavey))
                cshy = lmfpn*sqrt(tgavey/mi(iigsp))*noavey * 
      .                         lgtmax(iigsp)/(lmfpn + lgtmax(iigsp))
-
-               qshy = cshy * (tgy0(ix,iy1,1)-tgy1(ix,iy1,1)) * gyf(ix,iy)
+               qshy = cshy * (tgy0(ix,iy1,1)-tgy1(ix,iy1,1))/dynog(ix,iy)
                hcyn(ix,iy) = cshy / 
-
      .                      (1 + (abs(qshy/qfly))**flgamtg)**(1./flgamtg)
                hcyi(ix,iy) = hcyi(ix,iy) + cfneut*cfneutsor_ei*hcyn(ix,iy)
 c     
@@ -2979,10 +2988,10 @@ c
 
 *  -- compute equipartition --
 ccc In detail, coef1 = qe**4*sqrt(me)*lnlam / ((2*pi)**1.5*eps0**2)
-      coef1 = feqp * 4.8e-15 * lnlam * sqrt(ev) * ev * mp
       do 74 iy = j2, j5
          do 73 ix = i2, i5
             a = max (te(ix,iy), temin*ev)
+            coef1 = feqp*4.8e-15*loglambda(ix,iy)*sqrt(ev)*ev*mp
             eqp(ix,iy) = coef1 * w3(ix,iy) * ne(ix,iy) / (a*sqrt(a))
 c...       reduce eqp when (te-ti)/(te+ti) << 1
             eqp(ix,iy) = eqp(ix,iy) * (a-ti(ix,iy))**2 / ( cutlo +
@@ -3726,7 +3735,7 @@ c  -- it is included in frici from mombal or mombalni
          do jfld = 1, nusp
            if (jfld .ne. ifld) then
 *     -- common factor in collision frequency --
-             a = lnlam * zi(ifld)**2 * zi(jfld)**2 *
+             awoll = zi(ifld)**2 * zi(jfld)**2 *
      .            (qe**4/(12*pi**2*eps0**2)) *
      .            sqrt (2*pi*mi(ifld)*mi(jfld)/(mi(ifld)+mi(jfld)))
 
@@ -3736,7 +3745,8 @@ c  -- it is included in frici from mombal or mombalni
                  ix2 = ixp1(ix,iy)
                  t0 = ni(ix,iy,ifld) * ni(ix,iy,jfld) * w2(ix,iy)
                  t1 = ni(ix2,iy,ifld)*ni(ix2,iy,jfld)*w2(ix2,iy)
-                 tv  = a*(t0+t1)/2
+                 awll = awoll*loglambda(ix,iy)
+                 tv  = awll*(t0+t1)/2
                  resmo(ix,iy,ifld) = resmo(ix,iy,ifld) +
      .                        tv * (up(ix,iy,jfld)-up(ix,iy,ifld))
                  fricnrl(ix,iy,ifld) = fricnrl(ix,iy,ifld) +
@@ -3770,6 +3780,8 @@ c  -- it is included in frici from mombal or mombalni
             feeycbo(ix) = 0.0e0
             w0(ix,iy) = 0.0e0
             w1(ix,iy) = 0.0e0
+            wvh(ix,iy,1) = 0.0e0
+	    wvh(ix,iy,2) = 0.0e0
   707    continue
   708 continue
 
@@ -3989,8 +4001,6 @@ cccMER For full double-null configuration, iysptrx is last closed flux surface.
      .                           ( ni(ix,iy,ifld) + ni(ix1,iy,ifld) ) *
      .                           ( rbfbt2(ix,iy) + rbfbt2(ix1,iy) ) *
      .                            temp1
-c             else
-c                 floxibgt(ix,iy,ifld)=0.0
              endif
              floxi(ix,iy) = floxi(ix,iy) + cfbgt*floxibgt(ix,iy,ifld)
   131      continue
@@ -4695,7 +4705,7 @@ c******************************************************************
                ix3 = ixm1(ix,iy-1)
 	       thetacc = 0.5*(angfx(ix1,iy) + angfx(ix,iy))
 	       dupdx = gx(ix,iy)*(upi(ix,iy,ifld)-upi(ix1,iy,ifld))
-               w1(ix,iy) = w1(ix,iy) +  cfvcsx(ifld)*cfvisx*cos(thetacc)*
+               wvh(ix,iy,ifld) = cfvcsx(ifld)*cfvisx*cos(thetacc)*
      .                                    visx(ix,iy,ifld)*dupdx**2
                if ( isxpty(ix,iy)==0 ) then  #1-sided deriv down in y
                  dupdy = 0.5*( upi(ix,iy,  ifld)+upi(ix1,iy  ,ifld) -
@@ -4713,35 +4723,13 @@ c******************************************************************
      .                           upi(ix,iy-1,ifld)-upi(ix3,iy-1,ifld))*
      .                                                     gyf(ix,iy-1) )
                endif
-               w1(ix,iy) = w1(ix,iy) + cfvcsy(ifld)*cfvisy*
+               wvh(ix,iy,ifld) = wvh(ix,iy,ifld) + cfvcsy(ifld)*cfvisy*
      .                                   visy(ix,iy,ifld)*dupdy**2
-	       w1(ix,iy) = w1(ix,iy) - sin(thetacc)*cfvcsy(ifld)*cfvisy*
+	       wvh(ix,iy,ifld) = wvh(ix,iy,ifld) -
+     .                             sin(thetacc)*cfvcsy(ifld)*cfvisy*
      .                                   visy(ix,iy,ifld)*dupdx*dupdy
-cccMER The following code was replaced by the above if-test;
-cccMER Are these equivalent ???
-cc               if(isxpty(ix,iy) .ne. 0 .or. iysptrx.eq.0) then
-cc                  w1(ix,iy) = w1(ix,iy) +
-cc     .              cfvcsy(ifld) * cfvisy * visy(ix,iy,ifld) * (
-cc     .              ( upi(ix,iy+1,ifld)+upi(ix2,iy+1,ifld)
-cc     .               -upi(ix,iy  ,ifld)-upi(ix1,iy  ,ifld) )*gyf(ix,iy) +
-cc     .              ( upi(ix,iy  ,ifld)+upi(ix1,iy  ,ifld)
-cc     .               -upi(ix,iy-1,ifld)-upi(ix3,iy-1,ifld) )*gyf(ix,iy-1)
-cc     .                                                  )**2 / 16
-cc               elseif(iy .eq. iysptrx) then
-cc                  w1(ix,iy) = w1(ix,iy) +
-cc     .              cfvcsy(ifld) * cfvisy * visy(ix,iy,ifld) * (
-cc     .              ( upi(ix,iy  ,ifld)+upi(ix1,iy  ,ifld)
-cc     .               -upi(ix,iy-1,ifld)-upi(ix3,iy-1,ifld) )*gyf(ix,iy-1)
-cc     .                                                 )**2 / 4
-cc               else
-cc                  w1(ix,iy) = w1(ix,iy) +
-cc     .              cfvcsy(ifld) * cfvisy * visy(ix,iy,ifld) * (
-cc     .              ( upi(ix,iy+1,ifld)+upi(ix2,iy+1,ifld)
-cc     .               -upi(ix,iy  ,ifld)-upi(ix1,iy  ,ifld) )*gyf(ix,iy)
-cc     .                                                  )**2 / 4
-cc               endif
-  155       continue
-            resei(ix,iy) = resei(ix,iy) + w1(ix,iy) * vol(ix,iy)
+            resei(ix,iy) = resei(ix,iy) + wvh(ix,iy,ifld)*vol(ix,iy)
+  155       continue   # loop over up species ifld
   156    continue
  157  continue
 
@@ -5084,7 +5072,7 @@ c ... Set up other inputs for fmombal, including flow velocities.
          uneut(misa) = up(ix,iy,1)  # use hydr ion as default (orig)
       enddo
       ldir = 2
-      dloglam = lnlam
+      dloglam = loglambda(ix,iy)
 
 c ... Call Steve Hirshman reduced-ion momentum-balance routine.
       call fmombal(amu,den,dloglam,epar,friction,gradp,gradt,
@@ -5240,7 +5228,8 @@ c ... of pressure and Ti at poloidal density-cell faces.
             endif
 c... NOTE:next coefficient 12*pi*sqrt(pi/2)*epsilon**2/e**4 = 5.624e54 in mks
             taud =cftaud*5.624e54*sqrt(mi(1))*mi(ifld)*tempa(misa)**1.5 /
-     .             ( lnlam*den(misa,nz)*zi(ifld)**2*(mi(1)+mi(ifld)) )
+     .             ( loglambda(ix,iy)*den(misa,nz)*zi(ifld)**2*
+     .                                                 (mi(1)+mi(ifld)) )
             taudeff = flxlimf*taud*den(misa,nz)*(1+2.65*z0)*(1+.285*z0) /
      .                         ( den(1,1)*(1+.24*z0)*(1+.93*z0) )
             upi(ix,iy,ifld) = up(ix,iy,1) + (taudeff/mi(1)) * (
@@ -5878,9 +5867,6 @@ c
       integer iym1,iyp1,iyp2,ixm1b,ixp1b,ixp2b
       logical isxyfl
       real(Size4) sec4, gettime
-      # Former Aux module variables
-      integer ix,iy,igsp,iv,iv1,iv2,iv3,ix1,ix2,ix3,ix4,ix5,ix6
-      real t,t0,t1,t2,a
 
       Use(Dim)      # nx,ny,nhsp,nisp,ngsp,nxpt
       Use(Xpoint_indices)      # ixlb,ixpt1,ixpt2,ixrb,iysptrx1
@@ -7687,8 +7673,6 @@ c...  variables are used, i.e., n,nv,nT, or n,v,T, or n,v,nT
 
 *  -- Local variables
       integer ifld
-      #Former Aux module variables
-      integer ix,iy,iv,iv1,iv2,ix1,igsp
       real nbv, nbvdot, nbidot, nbedot, nbgdot, yldot_np1, nbg2dot(ngsp)
 
 c...  If isflxvar=0, we use ni,v,Te,Ti,ng as variables, and the ODEs need
@@ -7819,8 +7803,6 @@ c   -------------------------------------------------------------------------
      &     ivolcurgt, mvolcurt
       real argr, argz
       integer isxjcsor, iexjcsor, isyjcsor, ieyjcsor, ifld, nj
-      #Former Aux module variables
-      integer ix,iy,igsp
 
 
 c...  Initialize values and arrays
@@ -9453,8 +9435,7 @@ c ... Calculate right-hand sides at unperturbed values of variables.
 
 c ... Calculate Jacobian matrix.
       tp = 0.
-      #Working array wk in place of sf in the call to jac_calc (J.Guterl)
-      call jac_calc_interface (neq, tp, yl, yldot0, lbw, ubw, wk,
+      call jac_calc (neq, tp, yl, yldot0, lbw, ubw, sf,
      .               nnzmx, jac, jacj, jaci)
 
       yl(neq+1) = -1.      # Turn-off Jacobian flag for pandf
@@ -11722,6 +11703,8 @@ c ... neoclassical effects
       Use(RZ_grid_info)  # bpol,b12,b32,bsqr
       Use(Bfield)   #rbfbt
       Use(Share)    # nxpt,geometry,nxc,cutlo
+      Use(Aux)      # ix,iy,igsp,iv,iv1,iv2,iv3,
+                    # ix1,ix2,ix3,ix4,ix5,ix6,tv,t0,t1,t2,a
       Use(Selec)    # i1,i2,i3,i4,i5,i6,i7,i8,xlinc,xrinc,ixs1,
                     # j1,j1p,j2,j2p,j3,j4,j5,j6,j5p,j6p,j7,j8,
       Use(Compla)   # ni,up,te,ti,ng,phi,v2cd,
-- 
2.17.1


From e0866b8903a84c1b309be3f39e71b7aaf0234ea5 Mon Sep 17 00:00:00 2001
From: Jerome Guterl <guterlj@fusion.gat.com>
Date: Thu, 22 Oct 2020 14:25:31 -0700
Subject: patch loglambda final

---
 bbb/bbb.v    | 0
 bbb/oderhs.m | 4 +++-
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/bbb/oderhs.m b/bbb/oderhs.m
index 3596e1f..f7e1e79 100755
--- a/bbb/oderhs.m
+++ b/bbb/oderhs.m
@@ -577,12 +577,14 @@ c    yldot is the RHS of ODE solver or RHS=0 for Newton solver (NKSOL)
      .     niz_floor, hflux, zflux, psorv, kionz0, pscx0, pxri, kcxrzig,
      .     nizm_floor, argx, massfac, ae, geyym, geyy0, geyyp, dgeyy0,
      .     dgeyy1, te_diss, wallfac, z1fac, bpolmin, rt2nus, epstmp, tv2
+      real awoll,awll
       integer izch, ihyd, iimp, jg, jz, nsm1, ifld_fcs, ifld_lcs
       real uuv, ne_sgvi, nbarx, argth, fac_rad, ffyi, ffyo
       real grdnv, qflx, qfly, cshx, cshy, qshx, qshy, lxtec, lxtic
       real lmfpn, lmfppar, lmfpperp
       real temp1, temp2, temp3, temp4, cutlo3, lambd_ci, lambd_ce
-cgrs  real teyc, glte   # used in commented-out code, and never computed
+      real upxavep1,upxave0,upxavem1,upf0,upfm1
+      real teev
       logical xccuts, xcturb
       integer iy1, ixmp2, iyp1, iyp2, iym1, ixs, ixf, iys, iyf,
      .        methnx, methny, iy2, i2pwr, i5pwr, j2pwr, j5pwr,
-- 
2.17.1

